# -*- coding: utf-8 -*-
"""Digit_reader.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AlxxlZk54MTSt8c9RDGN5zl38k3GoeX9
"""


def int_to_fa(num):
    d = { 0 : 'صفر', 1 : 'یک', 2 : 'دو', 3 : 'سه', 4 : 'چهار', 5 : 'پنج',
          6 : 'شش', 7 : 'هفت', 8 : 'هشت', 9 : 'نه', 10 : 'ده',
          11 : 'یازده', 12 : 'دوازده', 13 : 'سیزده', 14 : 'چهارده',
          15 : 'پانزده', 16 : 'شانزده', 17 : 'هفده', 18 : 'هجده',
          19 : 'نوزده', 20 : 'بیست',
          30 : 'سی', 40 : 'چهل', 50 : 'پنجاه', 60 : 'شصت',
          70 : 'هفتاد', 80 : 'هشتاد', 90 : 'نود' }
    k = 1000
    m = k * 1000
    b = m * 1000
    t = b * 1000

    assert(0 <= num)

    if (num < 20):
        return d[num]

    if (num < 100):
        if num % 10 == 0: return d[num]
        else: return d[num // 10 * 10] + ' و ' + d[num % 10]

    if (num < k):
        if num % 100 == 0: return d[num // 100] + ' صد'
        else: return d[num // 100] + ' صد و ' + int_to_fa(num % 100)

    if (num < m):
        if num % k == 0: return int_to_fa(num // k) + ' هزار'
        else: return int_to_fa(num // k) + ' هزار و ' + int_to_fa(num % k)

    if (num < b):
        if (num % m) == 0: return int_to_fa(num // m) + ' میلیون'
        else: return int_to_fa(num // m) + ' میلیون و ' + int_to_fa(num % m)

    if (num < t):
        if (num % b) == 0: return int_to_fa(num // b) + ' میلیارد'
        else: return int_to_fa(num // b) + ' میلیارد و ' + int_to_fa(num % b)

    if (num % t == 0): return int_to_fa(num // t) + ' تریلیون'
    else: return int_to_fa(num // t) + ' تریلیون و ' + int_to_fa(num % t)

    raise AssertionError('عدد بیش از اندازه بزرگ است: %s' % str(num))

from pydub import AudioSegment

def concatenate_audio_files(file_paths):
    # Initialize an empty audio segment
    combined_audio = AudioSegment.silent(duration=0)

    # Iterate through each file path and append the audio to the combined_audio
    for i, file_path in enumerate(file_paths):
        audio_segment = AudioSegment.from_file(file_path, format="wav", frame_rate=16000, channels=1, sample_width=2)
        if i > 0:
          combined_audio = combined_audio.overlay(audio_segment, position=len(combined_audio) - 50)

        combined_audio += audio_segment

    return combined_audio

def text_preprocess(text):
  tokenized = text.split()
  i = 0
  while i < len(tokenized):
      if tokenized[i] == "و":
          if i > 0:
              tokenized[i - 1] += tokenized[i]
          tokenized.pop(i)
      else:
          i += 1

  result = " ".join(tokenized)
  return result

def string_to_audio(text,formal):
  if (not formal):
    text=text_preprocess(text)
  tokenized = text.split()
  audio_files=[]
  for digit in tokenized:
    audio_files.append(f"Voices/"+digit+".wav")
  result_audio = concatenate_audio_files(audio_files)
  return result_audio
def int_to_audio(text,formal):
  texted_audio=int_to_fa(text)
  audio_files=string_to_audio(texted_audio,formal)
  return audio_files


input_str = input("Enter input: ")
formal_str = input("Enter formal (True or False): ")

try:
    formal = bool(formal_str.lower() == "true")
except ValueError:
    print("Invalid value for formal. Please enter either 'True' or 'False'.")
    exit()

if input_str.isdigit():
    result_audio = int_to_audio(int(input_str), formal)
else:
    result_audio = string_to_audio(input_str, formal)

# Export the concatenated audio to a new file
result_audio.export("output_combined.wav", format="wav")

print("Concatenation complete. Output file: output_combined.wav")


